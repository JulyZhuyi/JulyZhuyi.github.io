<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARQ协议</title>
    <url>/2021/04/19/ARQ%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ARQ是什么"><a href="#ARQ是什么" class="headerlink" title="ARQ是什么"></a>ARQ是什么</h1><p>&nbsp; </p>
<p><strong>自动重传请求（Automatic Repeat reQuest），从名字看来，虽然被称为一种协议，但是看起来像是一种策略</strong></p>
<blockquote>
<p>ARQ，也可以是 Automatic Repeat Query 的缩写，是一种在数据传输时，使用确认（Acknoledgements，就是我们常说的ACK，接收方发送一个消息，告诉发送方，自己是否正确接到了一个包体）和超时（Timeouts，在收到一个确认消息之前，等待的一个确定的时间段）机制，在不可靠的网络上，实现可靠的数据传输的错误控制方法。如果发送方在超时之前没有收到确认，通常会重新传输相应的包体，直到收到确认或者重试超过一定的次数。<br><strong><a href="https://en.wikipedia.org/wiki/Automatic_repeat_request">维基百科</a></strong></p>
</blockquote>
<p>&nbsp; </p>
<h1 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h1><h2 id="停止等待ARQ（Stop-amp-Wait）"><a href="#停止等待ARQ（Stop-amp-Wait）" class="headerlink" title="停止等待ARQ（Stop &amp; Wait）"></a>停止等待ARQ（Stop &amp; Wait）</h2><p>最为原始的一种ARQ实现方式。如下图：   </p>
<ul>
<li>发送方发送一帧后，必须等待接收方确认（ACK）才能发送下一帧。  </li>
<li>发送方发送完一个帧后，就会设置一个超时计时器，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。<br><img src="stop.jpg" alt="stop and wait">  </li>
</ul>
<h2 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h2><p>连续ARQ通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示：<br><img src="seq-arq.jpg" alt="stop and wait"><br>图(a)是发送方维持的一个发送窗口，它的意义在于，位于发送窗口的5个分组都可以连续发送出去，而不需要等待对方的确认，这样大大提高了信道的利用率。<br>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图（b），当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。  </p>
<p><strong>若发送过程中出现错误，连续ARQ采用的两种方式如下：</strong><br><strong>- 回退N帧（GO back N)</strong>  </p>
<ul>
<li>接受点丢弃从第一个没有收到的数据包开始的所有数据包</li>
<li>发送点收到NACK后，从NACK中指明的数据包开始重新发送  </li>
</ul>
<p><strong>- 选择性重传（Selective Repeat）</strong>  </p>
<ul>
<li>发送点连续发送数据包但对每个数据包都设有一个计时器</li>
<li>当在一定时间内没有收到某个数据包的ACK时，发送点只发送那个没有ACK的数据包<br>&nbsp;    </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>ARQ是一种在数据传输过程中，错误控制的策略，保证了数据的完整性和有序性。核心目的是在不可靠的网络上实现可靠的传输。比如，无线通信中在WCDMA和cdma2000无线通信中都采用了选择性重传ARQ和混合ARQ。       </p>
<p>在服务端开发方面，ARQ的思想给我们很多的启发。此外，这种策略的学习和理解，是我们理解更复杂的网络协议的基础。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql binlog</title>
    <url>/2021/04/27/Mysql-binlog/</url>
    <content><![CDATA[<h1 id="Binlog是什么"><a href="#Binlog是什么" class="headerlink" title="Binlog是什么"></a>Binlog是什么</h1><p>二进制日志，用于记录数据库的写入性操作信息，以二进制的方式保存在磁盘。是Mysql的逻辑日志，并且由Server层进行记录，与存储引擎无关。<br>&nbsp; </p>
<h1 id="Binlog的使用场景"><a href="#Binlog的使用场景" class="headerlink" title="Binlog的使用场景"></a>Binlog的使用场景</h1><p>   主从复制：在Master端开启binlog，然后将binlog日志发送到各个Slave端，由Slave端重放Binlog最终达到主从一致<br>   数据恢复：通过使用mysqlbinlog工具来恢复数据<br>&nbsp;<br>&nbsp;    </p>
<h1 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h1><p><code>show variables like &#39;binlog_format&#39; //查看binlog日志格式</code></p>
<h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><p>   <strong>语句模式 – 基于sql语句的复制，每一条会修改数据的sql语句会记录到binlog里</strong><br>    <strong>优点</strong>：不需要记录每行的变化，减少了Binlog日志量，节约了IO，提高性能<br>    <strong>缺点</strong>：由于记录的只是执行语句，为了这些语句能在Slave上正确运行， 因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句在Slave得到和在Master端执行时候相同的结果。另外Mysql的复制，像一些特定函数功能，Slave可与Master保持一致会有很多相关问题。</p>
<h2 id="row"><a href="#row" class="headerlink" title="row"></a>row</h2><p>   <strong>行模式 – 基于行的复制，不记录sql语句的上下文，只记录哪条记录被修改</strong><br>   <strong>优点</strong>：不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题<br>   <strong>缺点</strong>：需要记录每行记录的修改，可能会产生大量的日志内容<br>   注：新版本的MySQL对row模式做了优化，并不是所有的修改都会以row来记录，比如遇到表结构变更的时候会以statement模式来记录，如果遇到update或者delete等修改语句，还是会记录所有行的变更</p>
<h2 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h2><p>   <strong>混合模式</strong>  <em><strong><a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log-mixed.html">官方文档</a></strong></em><br>   5.1.8版本开始，提供mixed格式，即statement与row的混合模式，在一些特定环境下会自动切换。比如，以下情况mixed会转换成row模式<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 DML 语句更新一个 NDB 表时；  </span><br><span class="line">当函数中包含 UUID() 时；    </span><br><span class="line">2 个及以上包含 AUTO_INCREMENT 字段的表被更新时；    </span><br><span class="line">执行 INSERT DELAYED 语句时；    </span><br><span class="line">用 UDF 时；     </span><br><span class="line">视图中必须要求运用 row 时，例如建立视图时使用了 UUID() 函数；</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<h1 id="Binlog刷盘时机"><a href="#Binlog刷盘时机" class="headerlink" title="Binlog刷盘时机"></a>Binlog刷盘时机</h1><p>   <strong>sync_binlog参数 — 同步binlog，持久化到硬盘，取值0，1，N</strong><br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:  不去强制要求，由系统判断刷盘时机  </span><br><span class="line">1:  每次commit的时候将binlog写入磁盘   </span><br><span class="line">N:  每N个事务才会将Binlog写入磁盘</span><br></pre></td></tr></table></figure></p>
<pre><code>show variables like &#39;sync_binlog&#39;; //查看参数设置
set global sync_binlog=0; //设置sync_binlog参数值
</code></pre>
<p>&nbsp;</p>
<h1 id="Binlog其他相关语句"><a href="#Binlog其他相关语句" class="headerlink" title="Binlog其他相关语句"></a>Binlog其他相关语句</h1><pre><code>show variables like &#39;log_bin&#39;;  //查看是否开启binlog日志
show variables like &#39;binlog_format&#39;; //查看binlog日志格式
show global variables like &#39;%log%&#39;; //查看binlog所在目录
show binary logs;  //查看当前服务器使用的binlog文件及大小
show binlog events in &#39;binlog.000017&#39;; //查看具体一个binlog文件的内容
</code></pre>
<p>&nbsp;</p>
<h1 id="mysqlbinlog命令的使用及说明"><a href="#mysqlbinlog命令的使用及说明" class="headerlink" title="mysqlbinlog命令的使用及说明"></a>mysqlbinlog命令的使用及说明</h1><p>   其命令可以使binlog日志以文本的方式显示，如下图<br>    <img src="mysqlbinlog.png" alt="mysqlbinlog"><br>    图片中日志的说明如下：<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position：位于文件中的位置，说明该事件记录从文件第210306个字节开始  &#x2F;&#x2F;#210306       </span><br><span class="line">timestamp：事件发生的时间戳 &#x2F;&#x2F;22:25:42   </span><br><span class="line">server id：服务器标识   </span><br><span class="line">end_log_pos：表示下一个事件开始的位置     </span><br><span class="line">thread_id：执行该事件的线程ID     </span><br><span class="line">exec_time：时间执行花费的时间      </span><br><span class="line">error_code：错误码，0意味着没有发生错误    </span><br><span class="line">type：事件类型Query </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>binlog</tag>
        <tag>mysql日志</tag>
      </tags>
  </entry>
  <entry>
    <title>relay-log和主从复制</title>
    <url>/2021/04/28/relay-log%E5%92%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>redis哨兵机制</title>
    <url>/2021/05/13/redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一、主从复制的问题"><a href="#一、主从复制的问题" class="headerlink" title="一、主从复制的问题"></a>一、主从复制的问题</h1><p>redis主从复制有个缺点，当主机master宕机以后，我们需要人工解决切换，比如使用slaveof on one。主从复制并没事实现高可用，高可用需要在某台机器发生故障之后，其他后备的机器可以迅速的接替并提供服务。</p>
<h1 id="二、如何解决"><a href="#二、如何解决" class="headerlink" title="二、如何解决"></a>二、如何解决</h1><p>如果我们有一个监控程序能够监控各个机器的状态，并及时调整，将手动操作变成自动的。Sentinel就是解决此问题的。</p>
<h1 id="三、哨兵机制的原理"><a href="#三、哨兵机制的原理" class="headerlink" title="三、哨兵机制的原理"></a>三、哨兵机制的原理</h1><p>Redis Sentinel一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对Redis数据节点以及其他的Sentinel节点进行监控，如果发现节点不可达时，会对节点做下线标识。<br>如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”。当大多数Sentinel认为主节点不可达时，它们会选举出一个Sentinel节点进行故障转移的工作，同时会将整个变化通知Redis应用方。整个过程是自动的，不需要人工介入，所以有效的解决了Redis高可用的问题。<br><img src="framework.jpg" alt="framework"> </p>
<h1 id="四、Sentinel包含的功能"><a href="#四、Sentinel包含的功能" class="headerlink" title="四、Sentinel包含的功能"></a>四、Sentinel包含的功能</h1><p>监控：Sentinel会定期检查Redis数据节点，以及其他Sentinel节点是否可达<br>通知：Sentinel会将故障转移的结果通知给应用方<br>主节点故障转移：实现从节点晋升主节点并维护后续正确的主从关系<br>充当配置中心：如果发生故障转移，会通知将master的新地址写在配置中心告诉客户端<br>&nbsp; </p>
<h1 id="五、Sentinel实现原理"><a href="#五、Sentinel实现原理" class="headerlink" title="五、Sentinel实现原理"></a>五、Sentinel实现原理</h1><h3 id="1、检测问题"><a href="#1、检测问题" class="headerlink" title="1、检测问题"></a>1、检测问题</h3><p>– 主要是三个定时任务<br>每隔10秒， 每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。<br>每隔2秒， 每个Sentinel节点会向Redis数据节点的__sentinel__： hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息， 同时每个Sentinel节点也会订阅该频道， 来了解其他Sentinel节点以及它们对主节点的判断。<br>每隔1秒， 每个Sentinel节点会向主节点、 从节点、 其余Sentinel节点发送一条ping命令做一次心跳检测， 来确认这些节点当前是否可达。  </p>
<h3 id="2、发现问题"><a href="#2、发现问题" class="headerlink" title="2、发现问题"></a>2、发现问题</h3><p><strong>主要讲的是客观下线和主关下线。如果Sentinel机器发现问题，就会对它主观下线。当多个Sentinel都发现有问题的时候，才会进行客观下线。</strong><br>sdown，即主观宕机，如果一个哨兵它自己觉得master宕机了，就是主观宕机<br>odown，即客观宕机，如果quorum数量的哨兵都认为一个master宕机了，则为客观宕机<br>哨兵在ping一个master的时候，如果超过了is-master-down-after-milliseconds指定的毫秒数之后，就是达到了sdown，就主观认为master宕机了。<br>如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机，就完成了sdown到odown的转换。</p>
<h3 id="3、解决问题-领导者选举"><a href="#3、解决问题-领导者选举" class="headerlink" title="3、解决问题-领导者选举"></a>3、解决问题-领导者选举</h3><p><strong>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来，主要通过下面几个步骤：</strong><br>按照slave优先级进行排序，slave priority越低，优先级就越高。<br>如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。<br>如果上面两个条件都相同，那么选择一个run id比较小的那个slave</p>
<h3 id="4、解决问题-故障转移"><a href="#4、解决问题-故障转移" class="headerlink" title="4、解决问题-故障转移"></a>4、解决问题-故障转移</h3><p>a. 领导者sentinel从slave中选一台，对这个slave执行slaveof no one 让其成为master。<br>b. 向剩余的slave发送命令，执行slaveof 让其成为新master的slave节点。此时新master不会对slave进行全量复制（这个通过查看新master和slave的日志文件看到确实没有进行全量复制，而是Trying a partial resynchronization  …即部分复制），而是进行一个部分复制（如果偏移量不超出新master的复制积压缓冲区的话）<br>c. 故障转移后，sentinel会关注原master，如果原master重启，sentinel会将让其同步新master，它自己就变成了slave。此时master会对这个重启的slave进行全量复制。<br>&nbsp; </p>
<h1 id="六、哨兵常见问题与解决方法"><a href="#六、哨兵常见问题与解决方法" class="headerlink" title="六、哨兵常见问题与解决方法"></a>六、哨兵常见问题与解决方法</h1><p><strong>哨兵在发现master node挂掉之后，其中一个slave node会提升为master node。在这过程中，可能会发生数据丢失。</strong></p>
<h2 id="主从异步导致的数据丢失"><a href="#主从异步导致的数据丢失" class="headerlink" title="主从异步导致的数据丢失"></a>主从异步导致的数据丢失</h2><p><strong>问题：</strong>因为master-&gt;slave的复制是异步的，有可能部分没有来得及复制master就宕机了<br><strong>解决：</strong>配置min-slaves-max-lag=10（ 数据复制和同步的延迟不能超过10S），当我们的slave在数据复制的时候，发现返回的ACK时延太长达到了 min-slaves-max-lag 配置，这个时候就会认为如果master宕机就会导致大量数据丢失，提前进行了预测，就不再去接收客户端的任何请求了，来将丢失的数据降低在可控范围内。<br><img src="sovle.jpg" alt="solve"> </p>
<h2 id="脑裂导致的数据丢失"><a href="#脑裂导致的数据丢失" class="headerlink" title="脑裂导致的数据丢失"></a>脑裂导致的数据丢失</h2><p><strong>问题：</strong>所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。<br><strong>解决：</strong>设置min-slaves-to-write（主库连接的从库中 至少有 N 个从库）、min-slaves-max-lag=10（ 数据复制和同步的延迟不能超过10S） 如果master出现了脑裂与其他的slave失去了通信，master不能给指定数量的salve发送数据，slave超过10S没有给自己返回ack消息，master就会拒接客户端的写入。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis哨兵机制</tag>
        <tag>redis高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisCluster原理</title>
    <url>/2021/05/17/RedisCluster%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
</search>
