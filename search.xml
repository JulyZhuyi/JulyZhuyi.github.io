<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARQ协议</title>
    <url>/2021/04/19/ARQ%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ARQ是什么"><a href="#ARQ是什么" class="headerlink" title="ARQ是什么"></a>ARQ是什么</h1><p>&nbsp; </p>
<p><strong>自动重传请求（Automatic Repeat reQuest），从名字看来，虽然被称为一种协议，但是看起来像是一种策略</strong></p>
<blockquote>
<p>ARQ，也可以是 Automatic Repeat Query 的缩写，是一种在数据传输时，使用确认（Acknoledgements，就是我们常说的ACK，接收方发送一个消息，告诉发送方，自己是否正确接到了一个包体）和超时（Timeouts，在收到一个确认消息之前，等待的一个确定的时间段）机制，在不可靠的网络上，实现可靠的数据传输的错误控制方法。如果发送方在超时之前没有收到确认，通常会重新传输相应的包体，直到收到确认或者重试超过一定的次数。<br><strong><a href="https://en.wikipedia.org/wiki/Automatic_repeat_request">维基百科</a></strong></p>
</blockquote>
<p>&nbsp; </p>
<h1 id="常见策略"><a href="#常见策略" class="headerlink" title="常见策略"></a>常见策略</h1><h2 id="停止等待ARQ（Stop-amp-Wait）"><a href="#停止等待ARQ（Stop-amp-Wait）" class="headerlink" title="停止等待ARQ（Stop &amp; Wait）"></a>停止等待ARQ（Stop &amp; Wait）</h2><p>最为原始的一种ARQ实现方式。如下图：   </p>
<ul>
<li>发送方发送一帧后，必须等待接收方确认（ACK）才能发送下一帧。  </li>
<li>发送方发送完一个帧后，就会设置一个超时计时器，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。<br><img src="stop.jpg" alt="stop and wait">  </li>
</ul>
<h2 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h2><p>连续ARQ通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示：<br><img src="seq-arq.jpg" alt="stop and wait"><br>图(a)是发送方维持的一个发送窗口，它的意义在于，位于发送窗口的5个分组都可以连续发送出去，而不需要等待对方的确认，这样大大提高了信道的利用率。<br>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图（b），当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。  </p>
<p><strong>若发送过程中出现错误，连续ARQ采用的两种方式如下：</strong><br><strong>- 回退N帧（GO back N)</strong>  </p>
<ul>
<li>接受点丢弃从第一个没有收到的数据包开始的所有数据包</li>
<li>发送点收到NACK后，从NACK中指明的数据包开始重新发送  </li>
</ul>
<p><strong>- 选择性重传（Selective Repeat）</strong>  </p>
<ul>
<li>发送点连续发送数据包但对每个数据包都设有一个计时器</li>
<li>当在一定时间内没有收到某个数据包的ACK时，发送点只发送那个没有ACK的数据包<br>&nbsp;    </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;<br>ARQ是一种在数据传输过程中，错误控制的策略，保证了数据的完整性和有序性。核心目的是在不可靠的网络上实现可靠的传输。比如，无线通信中在WCDMA和cdma2000无线通信中都采用了选择性重传ARQ和混合ARQ。       </p>
<p>在服务端开发方面，ARQ的思想给我们很多的启发。此外，这种策略的学习和理解，是我们理解更复杂的网络协议的基础。</p>
]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql binlog</title>
    <url>/2021/04/27/Mysql-binlog/</url>
    <content><![CDATA[<h1 id="Binlog是什么"><a href="#Binlog是什么" class="headerlink" title="Binlog是什么"></a>Binlog是什么</h1><p>二进制日志，用于记录数据库的写入性操作信息，以二进制的方式保存在磁盘。是Mysql的逻辑日志，并且由Server层进行记录，与存储引擎无关。<br>&nbsp; </p>
<h1 id="Binlog的使用场景"><a href="#Binlog的使用场景" class="headerlink" title="Binlog的使用场景"></a>Binlog的使用场景</h1><p>   主从复制：在Master端开启binlog，然后将binlog日志发送到各个Slave端，由Slave端重放Binlog最终达到主从一致<br>   数据恢复：通过使用mysqlbinlog工具来恢复数据<br>&nbsp;<br>&nbsp;    </p>
<h1 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h1><p><code>show variables like &#39;binlog_format&#39; //查看binlog日志格式</code></p>
<h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><p>   <strong>语句模式 – 基于sql语句的复制，每一条会修改数据的sql语句会记录到binlog里</strong><br>    <strong>优点</strong>：不需要记录每行的变化，减少了Binlog日志量，节约了IO，提高性能<br>    <strong>缺点</strong>：由于记录的只是执行语句，为了这些语句能在Slave上正确运行， 因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句在Slave得到和在Master端执行时候相同的结果。另外Mysql的复制，像一些特定函数功能，Slave可与Master保持一致会有很多相关问题。</p>
<h2 id="row"><a href="#row" class="headerlink" title="row"></a>row</h2><p>   <strong>行模式 – 基于行的复制，不记录sql语句的上下文，只记录哪条记录被修改</strong><br>   <strong>优点</strong>：不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题<br>   <strong>缺点</strong>：需要记录每行记录的修改，可能会产生大量的日志内容<br>   注：新版本的MySQL对row模式做了优化，并不是所有的修改都会以row来记录，比如遇到表结构变更的时候会以statement模式来记录，如果遇到update或者delete等修改语句，还是会记录所有行的变更</p>
<h2 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h2><p>   <strong>混合模式</strong><br>   5.1.8版本开始，提供mixed格式，即statement与row的混合模式，在一些特定环境下会自动切换。比如，以下情况mixed会转换成row模式<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 DML 语句更新一个 NDB 表时；  </span><br><span class="line">当函数中包含 UUID() 时；    </span><br><span class="line">2 个及以上包含 AUTO_INCREMENT 字段的表被更新时；    </span><br><span class="line">执行 INSERT DELAYED 语句时；    </span><br><span class="line">用 UDF 时；     </span><br><span class="line">视图中必须要求运用 row 时，例如建立视图时使用了 UUID() 函数；</span><br></pre></td></tr></table></figure><br>&nbsp;</p>
<h1 id="Binlog刷盘时机"><a href="#Binlog刷盘时机" class="headerlink" title="Binlog刷盘时机"></a>Binlog刷盘时机</h1><p>   <strong>sync_binlog参数 — 同步binlog，持久化到硬盘，取值0，1，N</strong><br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:  不去强制要求，由系统判断刷盘时机  </span><br><span class="line">1:  每次commit的时候将binlog写入磁盘   </span><br><span class="line">N:  每N个事务才会将Binlog写入磁盘</span><br></pre></td></tr></table></figure></p>
<pre><code>show variables like &#39;sync_binlog&#39;; //查看参数设置
set global sync_binlog=0; //设置sync_binlog参数值
</code></pre>
<p>&nbsp;</p>
<h1 id="Binlog其他相关语句"><a href="#Binlog其他相关语句" class="headerlink" title="Binlog其他相关语句"></a>Binlog其他相关语句</h1><pre><code>show variables like &#39;log_bin&#39;;  //查看是否开启binlog日志
show variables like &#39;binlog_format&#39;; //查看binlog日志格式
show global variables like &#39;%log%&#39;; //查看binlog所在目录
show binary logs;  //查看当前服务器使用的binlog文件及大小
show binlog events in &#39;binlog.000017&#39;; //查看具体一个binlog文件的内容
</code></pre>
<p>&nbsp;</p>
<h1 id="mysqlbinlog命令的使用及说明"><a href="#mysqlbinlog命令的使用及说明" class="headerlink" title="mysqlbinlog命令的使用及说明"></a>mysqlbinlog命令的使用及说明</h1><p>   其命令可以使binlog日志以文本的方式显示，如下图<br>    <img src="mysqlbinlog.png" alt="mysqlbinlog"><br>    图片中日志的说明如下：<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position：位于文件中的位置，说明该事件记录从文件第210306个字节开始  &#x2F;&#x2F;#210306       </span><br><span class="line">timestamp：事件发生的时间戳 &#x2F;&#x2F;22:25:42   </span><br><span class="line">server id：服务器标识   </span><br><span class="line">end_log_pos：表示下一个事件开始的位置     </span><br><span class="line">thread_id：执行该事件的线程ID     </span><br><span class="line">exec_time：时间执行花费的时间      </span><br><span class="line">error_code：错误码，0意味着没有发生错误    </span><br><span class="line">type：事件类型Query </span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
